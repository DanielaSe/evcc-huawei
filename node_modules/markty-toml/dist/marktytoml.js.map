{"version":3,"sources":["../node_modules/markty/dist/markty.es.js","../src/index.js"],"names":["markty","str","reg","rules","unlimited","prev","match","chunk","last","out","tokenizer","exec","substring","index","lastIndex","test","RegExp","marktytoml","TOML","let","matchThis","json","replace","s","literal","string","setWithPath","trim","parseBody","Object","assign","JSON","parse","stringify","replacer","reviver","k","v","charAt","length","slice","Number","Infinity","parseInt","toString","toLowerCase","obj","keys","val","asArray","split","x","i","l","t","substr","Array","push","NaN"],"mappings":"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","file":"marktytoml.js","sourcesContent":["/* eslint no-unused-vars: \"warn\" */\nfunction markty(str, reg, rules, unlimited) {\n  if ( unlimited === void 0 ) unlimited = false;\n\n  var prev, match, chunk, last = 0, out = '';\n  var tokenizer = reg;\n  while ( (match = tokenizer.exec(str)) ) {\n    prev = str.substring(last, match.index);\n    last = tokenizer.lastIndex;\n\n    if (rules && typeof(rules) === \"function\") {\n      chunk = rules(str, match);\n    } else {\n      chunk = rules;\n    }\n\n    out += prev;\n    out += chunk;\n  }\n  out += str.substring(last);\n\n  if( tokenizer.test(out) && unlimited === true ) {\n    return markty(out, new RegExp(tokenizer), rules, true);\n  } else {\n    return out;\n  }\n}\n\nexport default markty;\n//# sourceMappingURL=markty.es.js.map\n","/*eslint no-unused-vars: 1*/\nimport markty from 'markty'\n\n\nexport default function marktytoml (TOML) {\n  let matchThis = new RegExp(`^\\\\s*\\\\[(\\\\[)?(.*?)\\\\]\\\\]?(?= *$)((?:[\\\\w\\\\W](?!^\\\\s*\\\\[))*)`, 'gm')\n  let json = {}\n\n  // preprocess to assert the string starts with a node like []\n  TOML = TOML[0] === \"[\" ? TOML : \"[]\\n\"+TOML\n\n  // catch edge cases before processing\n  TOML = TOML.replace(/('{3,}(?:(?!'{3,})[\\w\\W]+?)'{3,})/gm, (s, literal)=> {\n    // If string literal simulates a header, like [grand.parent], \n    // we should escape it so that the process doesn't think it's a genuine header.\n    // Neutralize any line starting with [ and convert it to ⭼[⭺ (to be converted back later)\n    if(literal){return literal.replace(/^(\\s*)(\\[)/gm, '$1__>>[<<__')}\n  })\n\n  markty(TOML, matchThis, (string, match) => {\n      // let [token, header_array, header_path, body] = match\n      // let [  0,        1,            2,      3   ] = match\n\n      if (match[1]){  // header is like [[grand.parent]]\n        // @TODO: Should implement array blocks\n        setWithPath(json, match[2].trim(), parseBody(match[3]), true)\n      }\n      else if (match[2] === \"\"){ // header is like []\n        json = Object.assign({}, json, parseBody(match[3]))\n      }\n      else {  // header is like [grand.parent]\n        setWithPath(json, match[2].trim(), parseBody(match[3]), false)\n      }\n\n  })\n\n  return  JSON.parse(JSON.stringify(json, replacer), reviver)\n}\n\nfunction parseBody (TOML) {\n\n  let matchThis = new RegExp(`^[ \\t]*(.+?) *[=:] *(?:\"((?!\")[\\\\w\\\\W]+?)\"|'{3,}((?!'{3,})[\\\\w\\\\W]+?)'{3,}|(\\\\[[\\\\w\\\\W]+?(?:(?: *])+ *$\\\\n*)+)|(\\\\{[\\\\w\\\\W]+?(?:(?: *})+ *$\\\\n*)+)|(.+) *)|^(.+)$`, 'gm')\n\n  let json = {}\n\n  markty(TOML, matchThis, (string, match) => {\n    // let [token (0),\n    //   key (1),\n    //   val_quotes (2), val_literal (3), val_array (4), val_json (5), val_noquotes (6),\n    //   trash (7)\n    // ] = match, k, v\n\n    let k, v\n\n    if (match[1]){\n      if (match[1].charAt(0) === \"#\") return\n      k = match[1].charAt(0) === '\\\"' && match[1].charAt(match[1].length-1) === '\\\"' ? match[1].slice(1, -1) : match[1]\n      if (match[2] || match[3]) {\n        v = match[2] || match[3].replace(/^(\\s*)(__>>\\[<<__)/gm, \"$1[\")\n      }\n      if (match[4] || match[5]) {\n        v = JSON.parse(`${match[4] || match[5]}`)\n      }\n      // val_noquotes is important: it is a value NOT surrounded by double-quotes\n      if (match[6]) {\n        match[6] = match[6].trim()\n        if (+match[6] === +match[6]){ v = Number(match[6])}\n        else if (match[6] === 'true' || match[6] === 'false'){ v = (match[6] === 'true') }\n        else if (match[6] === 'inf' || match[6] === '+inf'){ v = Infinity }\n        else if (match[6] === '-inf'){ v = -Infinity }\n        else if (parseInt(match[6], 16).toString(16) === match[6].toLowerCase() ){ v = parseInt(match[6], 16) }\n        else if (parseInt(match[6], 8).toString(8) === match[6].toLowerCase() ){ v = parseInt(match[6], 8) }\n        else if (parseInt(match[6], 2).toString(2) === match[6].toLowerCase() ){ v = parseInt(match[6], 2) }\n        // else if (dateRegex) {\n        //     /(\\d{4})-(\\d{1,2})-(\\d{1,2})(?:[ T](\\d{1,2}):(\\d{1,2})(?::(\\d{1,2}))?)?([Z+-])?(?:(\\d{1,2}):(\\d{2}))?/\n        // }\n        else { v = match[6] }\n      }\n      json[k] = v\n      return ''\n    }\n    // If a user puts a value on multiple lines (using line-breaks), WITHOUT using double-quotes\n    // everything coming after the line-break is trash\n    else if (match[7]) return ''\n  })\n\n  return json\n}\n\n// function sanitizeSpaces(str) {\n//   str = str.trim()\n//   str = (str.substr(0,1) === '\"' && str.substr(-1) === '\"') ? str.slice(1,-1) : str\n//   return str\n// }\n\nfunction setWithPath(obj, keys, val, asArray) {\n\tasArray = asArray ? true : false\n  keys.split && (keys=keys.split('.'))\n\tvar i=0, l=keys.length, t=obj, x\n\tfor (; i < l; ++i) {\n\n    // sanitize spaces\n    keys[i] = keys[i].trim()\n    keys[i] = (keys[i].substr(0,1) === '\"' && keys[i].substr(-1) === '\"') ? keys[i].slice(1,-1) : keys[i]\n\n    if (t instanceof Array){x = t[t.length-1]; i--} else { x = t[keys[i]] }\n\n    if (i === l-1) {\n      x instanceof Array ? t[keys[i]].push(val) : (t[keys[i]]=asArray?[val]:val)\n    }\n    else {\n      x instanceof Array ? ( t = x ) : (t = t[keys[i]] = (x == null ? {} : x))\n    }\n\t}\n}\n\n\nlet replacer = function(k,v){    \n  if (v !== v) { return '__>>NaN<<__' }\n  if (v === Infinity) { return '__>>Inf<<__' }\n  if (v === -Infinity) { return '__>>-Inf<<__' }\n  return v\n}\n\nlet reviver = function(k,v){\n  if (v === '__>>NaN<<__') { return NaN }\n  if (v === '__>>Inf<<__') { return Infinity }\n  if (v === '__>>-Inf<<__') { return -Infinity }\n  return v\n}"]}