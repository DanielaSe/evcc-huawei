import { d as defineComponent, r as ref, p as onMounted, w as watch, o as onUnmounted, a as openBlock, b as createElementBlock, D as createApp, ab as Case, ac as Text, Z as vModelText, ad as vModelSelect, ae as vModelRadio, af as vModelCheckbox, ag as vModelDynamic } from "./vendor.2833ae3d.js";
import { d as applyStateToVariant } from "./global-components.6736b2a9.js";
var main = "";
var histoireSetup = () => {
};
var setup = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": histoireSetup
}, Symbol.toStringTag, { value: "Module" }));
var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
function indent(lines, count = 1) {
  return lines.map((line) => `${"  ".repeat(count)}${line}`);
}
function unindent(code) {
  const lines = code.split("\n");
  let indentLevel = -1;
  let indentText;
  const linesToAnalyze = lines.filter((line) => line.trim().length > 0);
  for (const line of linesToAnalyze) {
    const match = /^\s*/.exec(line);
    if (match && (indentLevel === -1 || indentLevel > match[0].length)) {
      indentLevel = match[0].length;
      indentText = match[0];
    }
  }
  const result = [];
  for (const line of lines) {
    result.push(line.replace(indentText, ""));
  }
  return result.join("\n").trim();
}
function createAutoBuildingObject(format, specialKeysHandler, key = "", depth = 0) {
  const cache = {};
  if (depth > 32)
    return { key, cache, target: {}, proxy: () => key };
  const target = () => {
    const k = key + "()";
    return format ? format(k) : k;
  };
  const proxy = new Proxy(target, {
    get(_, p) {
      if (p === "__autoBuildingObject") {
        return true;
      }
      if (p === "__autoBuildingObjectGetKey") {
        return key;
      }
      if (specialKeysHandler) {
        const fn = specialKeysHandler(target, p);
        if (fn) {
          return fn();
        }
      }
      if (p === "toString") {
        const k = key + ".toString()";
        return () => format ? format(k) : k;
      }
      if (p === Symbol.toPrimitive) {
        return () => format ? format(key) : key;
      }
      if (!cache[p]) {
        const childKey = key ? `${key}.${p.toString()}` : p.toString();
        const child = createAutoBuildingObject(format, specialKeysHandler, childKey, depth + 1);
        cache[p] = __spreadValues({ key: childKey }, child);
      }
      return cache[p].proxy;
    },
    apply(_, thisArg, args) {
      const k = `${key}(${args.join(", ")})`;
      return format ? format(k) : k;
    }
  });
  return {
    key,
    cache,
    target,
    proxy
  };
}
const KEY_ESCAPE_REG = /[\s-.:|#@$Â£*%]/;
const MAX_SINGLE_LINE_ARRAY_LENGTH = 3;
function serializeJs(value) {
  if (value === void 0) {
    return "undefined";
  }
  if (value === null) {
    return "null";
  }
  if (typeof value === "string") {
    return `'${value}'`;
  }
  if (typeof value === "boolean") {
    return value ? "true" : "false";
  }
  if (Array.isArray(value)) {
    return printLines(arrayToSourceLines(value));
  }
  if (typeof value === "object") {
    return printLines(objectToSourceLines(value));
  }
  if (value == null ? void 0 : value.__autoBuildingObject) {
    return value;
  }
  if (typeof value === "function" && value.name) {
    return value.name;
  }
  return value.toString();
}
function printLines(lines) {
  return lines.map((line) => "  ".repeat(line.spaces) + line.line).join("\n");
}
function objectToSourceLines(object, indentCount = 0) {
  return createLines(indentCount, (lines) => {
    lines.push("{");
    lines.push(...createLines(1, (lines2) => {
      for (const key in object) {
        const value = object[key];
        let printedKey = key;
        if (KEY_ESCAPE_REG.test(key)) {
          printedKey = `'${printedKey}'`;
        }
        addLinesFromValue(lines2, value, `${printedKey}: `, ",");
      }
    }));
    lines.push("}");
  });
}
function arrayToSourceLines(array, indentCount = 0) {
  return createLines(indentCount, (lines) => {
    const contentLines = createLines(1, (lines2) => {
      for (const value of array) {
        addLinesFromValue(lines2, value, "", ",");
      }
    });
    if (contentLines.length === 0) {
      lines.push("[]");
    } else if (contentLines.length <= MAX_SINGLE_LINE_ARRAY_LENGTH && !contentLines.some((line) => line.spaces > 1)) {
      const [first] = contentLines;
      first.line = contentLines.map(({ line }) => line.substring(0, line.length - 1)).join(", ");
      first.line = `[${first.line}]`;
      first.spaces--;
      lines.push(first);
    } else {
      lines.push("[", ...contentLines, "]");
    }
  });
}
function createLines(indentCount, handler) {
  const lines = [];
  handler(lines);
  return lines.map((line) => {
    if (line.spaces != null) {
      line.spaces += indentCount;
      return line;
    }
    return { spaces: indentCount, line };
  });
}
function addLinesFromValue(lines, value, before, after) {
  let result;
  if (Array.isArray(value)) {
    lines.push(...wrap(arrayToSourceLines(value), before, after));
    return;
  } else if (value && typeof value === "object") {
    lines.push(...wrap(objectToSourceLines(value), before, after));
    return;
  } else if (typeof value === "string") {
    result = value.includes("'") ? `\`${value}\`` : `'${value}'`;
  } else if (typeof value === "undefined") {
    result = "undefined";
  } else if (value === null) {
    result = "null";
  } else if (typeof value === "boolean") {
    result = value ? "true" : "false";
  } else {
    result = value;
  }
  lines.push(before + result + after);
}
function wrap(lines, before, after) {
  lines[0].line = before + lines[0].line;
  lines[lines.length - 1].line += after;
  return lines;
}
const voidElements = [
  "area",
  "base",
  "br",
  "col",
  "embed",
  "hr",
  "img",
  "input",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
];
async function generateSourceCode(variant) {
  var _a, _b, _c, _d, _e, _f;
  const vnode = (_d = (_c = (_b = variant.slots()).default) == null ? void 0 : _c.call(_b, { state: (_a = variant.state) != null ? _a : {} })) != null ? _d : [];
  const list = Array.isArray(vnode) ? vnode : [vnode];
  const lines = [];
  for (const n in list) {
    const vnode2 = list[n];
    lines.push(...(await printVNode(vnode2, (_f = (_e = variant.state) == null ? void 0 : _e._hPropState) == null ? void 0 : _f[n])).lines);
  }
  return lines.join("\n");
}
async function printVNode(vnode, propsOverrides = null) {
  var _a, _b, _c;
  if (vnode.type === Text) {
    return {
      lines: [vnode.children],
      isText: true
    };
  }
  const lines = [];
  if (typeof vnode.type === "object" || typeof vnode.type === "string") {
    let genDirective = function(dirName, dir, valueCode = null) {
      var _a2;
      let modifiers = "";
      for (const key in dir.modifiers) {
        if (dir.modifiers[key]) {
          modifiers += `.${key}`;
        }
      }
      let arg = "";
      if (dir.arg) {
        arg = `:${dir.arg}`;
      }
      if (valueCode) {
        valueCode = valueCode.replace(/^\$(setup|props|data)\./g, "");
      }
      const valueLines = valueCode ? [valueCode] : serializeAndCleanJs(dir.value);
      const attr = [];
      const dirAttr = `v-${dirName}${arg}${modifiers}="`;
      if (valueLines.length > 1) {
        attr.push(`${dirAttr}${valueLines[0]}`);
        attr.push(...valueLines.slice(1, valueLines.length - 1));
        attr.push(`${valueLines[valueLines.length - 1]}"`);
        multilineAttrs = true;
      } else {
        attr.push(`${dirAttr}${(_a2 = valueLines[0]) != null ? _a2 : ""}"`);
      }
      attrs.push(attr);
    }, addAttr = function(prop, value) {
      var _a2, _b2, _c2;
      if (typeof value !== "string" || ((_a2 = vnode.dynamicProps) == null ? void 0 : _a2.includes(prop))) {
        let directive = ":";
        if (prop.startsWith("on")) {
          directive = "@";
        }
        const arg = directive === "@" ? `${prop[2].toLowerCase()}${prop.slice(3)}` : prop;
        const vmodelListener = `onUpdate:${prop}`;
        if (directive === ":" && ((_b2 = vnode.dynamicProps) == null ? void 0 : _b2.includes(vmodelListener))) {
          skipProps.push(vmodelListener);
          const listener = vnode.props[vmodelListener];
          const listenerSource = listener.toString();
          let valueCode;
          const result = /\(\$event\) => (.*?) = \$event/.exec(listenerSource);
          if (result) {
            valueCode = result[1];
          }
          const modifiersKey = `${prop === "modelValue" ? "model" : prop}Modifiers`;
          const modifiers = (_c2 = vnode.props[modifiersKey]) != null ? _c2 : {};
          skipProps.push(modifiersKey);
          genDirective("model", {
            arg: prop === "modelValue" ? null : prop,
            modifiers,
            value
          }, valueCode);
          return;
        }
        let serialized;
        if (typeof value === "string" && value.startsWith("{{") && value.endsWith("}}")) {
          serialized = cleanupExpression(value.substring(2, value.length - 2).trim()).split("\n");
        } else if (typeof value === "function") {
          let code = cleanupExpression(value.toString().replace(/'/g, "\\'").replace(/"/g, "'"));
          const testResult = /function ([^\s]+)\(/.exec(code);
          if (testResult) {
            serialized = [testResult[1]];
          } else {
            if (code.startsWith("($event) => ")) {
              code = code.substring("($event) => ".length);
            }
            serialized = code.split("\n");
          }
        } else {
          serialized = serializeAndCleanJs(value);
        }
        if (serialized.length > 1) {
          multilineAttrs = true;
          const indented = [`${directive}${arg}="${serialized[0]}`];
          indented.push(...serialized.slice(1, serialized.length - 1));
          indented.push(`${serialized[serialized.length - 1]}"`);
          attrs.push(indented);
        } else {
          attrs.push([`${directive}${arg}="${serialized[0]}"`]);
        }
      } else {
        attrs.push([`${prop}="${value}"`]);
      }
    };
    if (((_a = vnode.type) == null ? void 0 : _a.__asyncLoader) && !vnode.type.__asyncResolved) {
      await vnode.type.__asyncLoader();
    }
    const attrs = [];
    let multilineAttrs = false;
    const skipProps = [
      "key"
    ];
    if (vnode.dirs) {
      for (const dir of vnode.dirs) {
        if (dir.dir === vModelText || dir.dir === vModelSelect || dir.dir === vModelRadio || dir.dir === vModelCheckbox || dir.dir === vModelDynamic) {
          const listenerKey = `onUpdate:${(_b = dir.arg) != null ? _b : "modelValue"}`;
          const listener = vnode.props[listenerKey];
          let valueCode = null;
          if (listener) {
            skipProps.push(listenerKey);
            const listenerSource = listener.toString();
            const result = /\(\$event\) => (.*?) = \$event/.exec(listenerSource);
            if (result) {
              valueCode = result[1];
            }
          }
          genDirective("model", dir, valueCode);
        } else if (dir.instance._ || dir.instance.$) {
          const target = (_c = dir.instance.$) != null ? _c : dir.instance._;
          let dirName;
          for (const directives of [target.directives, target.appContext.directives]) {
            for (const key in directives) {
              if (target.directives[key] === dir.dir) {
                dirName = key;
                break;
              }
            }
            if (dirName)
              break;
          }
          if (dirName) {
            genDirective(dirName, dir);
          }
        }
      }
    }
    for (const prop in vnode.props) {
      if (skipProps.includes(prop) || propsOverrides && prop in propsOverrides) {
        continue;
      }
      const value = vnode.props[prop];
      addAttr(prop, value);
    }
    if (propsOverrides) {
      for (const prop in propsOverrides) {
        addAttr(prop, propsOverrides[prop]);
      }
    }
    if (attrs.length > 1) {
      multilineAttrs = true;
    }
    const tagName = getTagName(vnode);
    let isChildText = false;
    const childLines = [];
    if (typeof vnode.children === "string") {
      if (tagName === "pre") {
        childLines.push(vnode.children);
      } else {
        childLines.push(...vnode.children.split("\n"));
      }
      isChildText = true;
    } else if (Array.isArray(vnode.children)) {
      let isAllChildText;
      for (const child of vnode.children) {
        const result = await printVNode(child);
        if (result.isText) {
          if (isAllChildText === void 0) {
            isAllChildText = true;
          }
          const text = result.lines[0];
          if (!childLines.length || /^\s/.test(text)) {
            childLines.push(text.trim());
          } else {
            childLines[childLines.length - 1] += text;
          }
        } else {
          if (isAllChildText === void 0) {
            isAllChildText = false;
          }
          childLines.push(...result.lines);
        }
      }
      if (isAllChildText !== void 0) {
        isChildText = isAllChildText;
      }
    }
    if (vnode.children && typeof vnode.children === "object" && !Array.isArray(vnode.children)) {
      for (const key in vnode.children) {
        if (typeof vnode.children[key] === "function") {
          const autoObject = createAutoBuildingObject((key2) => `{{ ${key2} }}`, (target, p) => {
            if (p === "__v_isRef") {
              return () => false;
            }
          });
          const children = vnode.children[key](autoObject.proxy);
          const slotLines = [];
          for (const child of children) {
            slotLines.push(...(await printVNode(child)).lines);
          }
          const slotProps = Object.keys(autoObject.cache);
          if (slotProps.length) {
            childLines.push(`<template #${key}="{ ${slotProps.join(", ")} }">`);
            childLines.push(...indent(slotLines));
            childLines.push("</template>");
          } else if (key === "default") {
            childLines.push(...slotLines);
          } else {
            childLines.push(`<template #${key}>`);
            childLines.push(...indent(slotLines));
            childLines.push(`</template>`);
          }
        }
      }
    }
    const tag = [`<${tagName}`];
    if (multilineAttrs) {
      for (const attrLines of attrs) {
        tag.push(...indent(attrLines));
      }
      if (childLines.length > 0) {
        tag.push(">");
      }
    } else {
      if (attrs.length === 1) {
        tag[0] += ` ${attrs[0]}`;
      }
      if (childLines.length > 0) {
        tag[0] += ">";
      }
    }
    const isVoid = voidElements.includes(tagName.toLowerCase());
    if (childLines.length > 0) {
      if (childLines.length === 1 && tag.length === 1 && !attrs.length && isChildText) {
        lines.push(`${tag[0]}${childLines[0]}</${tagName}>`);
      } else {
        lines.push(...tag);
        lines.push(...indent(childLines));
        lines.push(`</${tagName}>`);
      }
    } else if (tag.length > 1) {
      lines.push(...tag);
      lines.push(isVoid ? ">" : "/>");
    } else {
      lines.push(`${tag[0]}${isVoid ? "" : " /"}>`);
    }
  } else if ((vnode == null ? void 0 : vnode.shapeFlag) & 1 << 4) {
    for (const child of vnode.children) {
      lines.push(...(await printVNode(child)).lines);
    }
  }
  return {
    lines
  };
}
function getTagName(vnode) {
  var _a, _b, _c, _d, _e;
  if (typeof vnode.type === "string") {
    return vnode.type;
  } else if ((_a = vnode.type) == null ? void 0 : _a.__asyncResolved) {
    const asyncComp = (_b = vnode.type) == null ? void 0 : _b.__asyncResolved;
    return (_c = asyncComp.name) != null ? _c : getNameFromFile(asyncComp.__file);
  } else if ((_d = vnode.type) == null ? void 0 : _d.name) {
    return vnode.type.name;
  } else if ((_e = vnode.type) == null ? void 0 : _e.__file) {
    return getNameFromFile(vnode.type.__file);
  }
  return "Anonymous";
}
function getNameFromFile(file) {
  const parts = /([^/]+)\.vue$/.exec(file);
  if (parts) {
    return Case.exports.pascal(parts[1]);
  }
  return "Anonymous";
}
function serializeAndCleanJs(value) {
  const isAutoBuildingObject = !!(value == null ? void 0 : value.__autoBuildingObject);
  const result = serializeJs(value);
  if (isAutoBuildingObject) {
    return [cleanupExpression(result.__autoBuildingObjectGetKey)];
  } else {
    return cleanupExpression(result).split("\n");
  }
}
function cleanupExpression(expr) {
  return expr.replace(/\$setup\./g, "");
}
const _sfc_main = /* @__PURE__ */ defineComponent({
  name: "SandboxVue3",
  props: {
    variant: {
      type: Object,
      required: true
    },
    story: {
      type: Object,
      required: true
    },
    slotName: {
      type: String,
      default: "default"
    }
  },
  emits: {
    ready: () => true
  },
  setup(__props, { emit }) {
    const props = __props;
    const sandbox = ref();
    let app;
    let mounting = false;
    async function mountVariant() {
      mounting = true;
      await props.variant.initState();
      let lastPropsTypesSnapshot;
      app = createApp({
        name: "SandboxVue3",
        render: () => {
          var _a, _b, _c, _d, _e, _f, _g;
          const vnodes = (_g = (_c = (_a = props.variant.slots()) == null ? void 0 : _a[props.slotName]) == null ? void 0 : _c.call(_a, {
            state: (_b = props.variant.state) != null ? _b : {}
          })) != null ? _g : (_f = (_d = props.story.slots()) == null ? void 0 : _d[props.slotName]) == null ? void 0 : _f.call(_d, {
            state: (_e = props.variant.state) != null ? _e : {}
          });
          if (props.slotName === "default") {
            const propsTypes = vnodes.filter((vnode) => typeof vnode.type === "object").map((vnode, index) => {
              var _a2, _b2, _c2;
              const propDefs = [];
              for (const key in vnode.type.props) {
                const prop = vnode.type.props[key];
                let types;
                let defaultValue;
                if (prop) {
                  const rawTypes = Array.isArray(prop.type) ? prop.type : [prop.type];
                  types = rawTypes.map((t) => {
                    switch (t) {
                      case String:
                        return "string";
                      case Number:
                        return "number";
                      case Boolean:
                        return "boolean";
                      case Object:
                        return "object";
                      case Array:
                        return "array";
                      default:
                        return "unknown";
                    }
                  });
                  defaultValue = typeof prop.default === "function" ? prop.default.toString() : prop.default;
                }
                propDefs.push({
                  name: key,
                  types,
                  required: prop == null ? void 0 : prop.required,
                  default: defaultValue
                });
                if ((_c2 = (_b2 = (_a2 = props.variant.state) == null ? void 0 : _a2._hPropState) == null ? void 0 : _b2[index]) == null ? void 0 : _c2[key]) {
                  vnode.props[key] = props.variant.state._hPropState[index][key];
                }
              }
              return {
                name: getTagName(vnode),
                index,
                props: propDefs
              };
            }).filter((def) => def.props.length);
            const snapshot = JSON.stringify(propsTypes);
            if (!lastPropsTypesSnapshot || lastPropsTypesSnapshot !== snapshot) {
              applyStateToVariant(props.variant, {
                _hPropDefs: propsTypes
              });
              if (!props.variant.state._hPropState) {
                applyStateToVariant(props.variant, {
                  _hPropState: {}
                });
              }
              lastPropsTypesSnapshot = snapshot;
            }
          }
          return vnodes;
        }
      });
      if (typeof (setup == null ? void 0 : void 0) === "function") {
        await (void 0)({
          app,
          story: props.story,
          variant: props.variant
        });
      }
      if (typeof props.variant.setupApp === "function") {
        await props.variant.setupApp({
          app,
          story: props.story,
          variant: props.variant
        });
      }
      const target = document.createElement("div");
      sandbox.value.appendChild(target);
      app.mount(target);
      emit("ready");
    }
    onMounted(async () => {
      if (props.variant.initState) {
        await mountVariant();
      }
    });
    watch(() => props.variant.initState, (value) => {
      if (value && !mounting) {
        mountVariant();
      }
    });
    onUnmounted(() => {
      app == null ? void 0 : app.unmount();
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "sandbox",
        ref: sandbox,
        class: "__histoire-sandbox htw-overflow-auto"
      }, null, 512);
    };
  }
});
const STATE_SYNC = "__histoire:state-sync";
const SANDBOX_READY = "__histoire:sandbox-ready";
const EVENT_SEND = "__histoire:event";
const PREVIEW_SETTINGS_SYNC = "__histoire:preview-settings-sync";
export { EVENT_SEND as E, PREVIEW_SETTINGS_SYNC as P, STATE_SYNC as S, _sfc_main as _, SANDBOX_READY as a, generateSourceCode as g, unindent as u };
